<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ProWatermark ä¸“ä¸šæ°´å°å·¥å…·</title>
    <style>
        :root {
            --primary: #2A2F35;
            --secondary: #4A90E2;
            --accent: #FF5A5F;
            --bg: #F8F9FC;
            --card-bg: #FFFFFF;
            --text: #2A2F35;
            --text-light: #6C757D;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), #4A4E55);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }
        .card {
            background: var(--card-bg);
            border-radius: 1rem;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 24px rgba(0,0,0,0.04);
        }

        .folder-item {
            display: flex;
            align-items: center;
            padding: 1rem;
            margin: 0.5rem 0;
            background: var(--bg);
            border-radius: 0.75rem;
            border: 1px solid #EDF2F7;
        }

        .dual-control {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            padding: 1rem;
            background: var(--bg);
            border-radius: 0.75rem;
        }

        .range-slider {
            flex: 1;
            height: 6px;
            background: #EDF2F7;
            border-radius: 3px;
            accent-color: var(--secondary);
        }

        .num-input {
            width: 100px;
            padding: 0.75rem;
            border: 2px solid #EDF2F7;
            border-radius: 0.75rem;
            font-size: 1rem;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--secondary);
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>å›¾ç‰‡æ°´å°æ‰¹é‡å¤„ç†å·¥å…·</h1>
            <p>ç”±â€œå¤§å­¦ä¸€ç‚¹é€šâ€å›¢é˜Ÿå¼€å‘</p>
        </header>

        <main>
            <div class="card">
                <h2>ğŸ“ ä»»åŠ¡é˜Ÿåˆ—</h2>
                <div id="folder-queue">
                    <button class="btn btn-primary" onclick="addFolderPair()">
                        ï¼‹ æ·»åŠ å¤„ç†ä»»åŠ¡
                    </button>
                </div>
            </div>

            <div class="card">
                <h2>âš™ï¸ å‚æ•°è®¾ç½®</h2>
                <div class="control-group">
                    <input type="file" id="watermark-file" 
                           class="btn" style="width:100%" accept="image/*">
                </div>
                
                <div class="control-group">
                    <label>ä¸é€æ˜åº¦</label>
                    <div class="dual-control">
                        <input type="range" class="range-slider" id="opacity" 
                               min="0" max="1" step="0.01" value="0.5">
                        <input type="number" class="num-input" id="opacity-input" 
                               min="0" max="100" value="50">
                        <span>%</span>
                    </div>
                </div>

                <div class="control-group">
                    <label>ç¼©æ”¾æ¯”ä¾‹</label>
                    <div class="dual-control">
                        <input type="range" class="range-slider" id="scale" 
                               min="0.1" max="5" step="0.01" value="1">
                        <input type="number" class="num-input" id="scale-input" 
                               min="10" max="500" value="100">
                        <span>%</span>
                    </div>
                </div>
            </div>
            <div class="card">
                <h2>ğŸ” å®æ—¶é¢„è§ˆ</h2>
                <div class="preview-nav">
                    <button class="btn btn-primary" onclick="changePreview(-1)">â† ä¸Šä¸€å¼ </button>
                    <span id="preview-counter" style="padding:0 1rem">å‡†å¤‡å°±ç»ª</span>
                    <button class="btn btn-primary" onclick="changePreview(1)">ä¸‹ä¸€å¼  â†’</button>
                </div>
                <canvas id="preview-canvas"></canvas>
            </div>

            <div style="text-align: center; margin: 2rem 0">
                <button class="btn btn-primary" onclick="startProcessing()" 
                        style="padding:1.25rem 3rem; font-size:1.1rem">
                    ğŸš€ å¼€å§‹æ‰¹é‡å¤„ç†
                </button>
                <div class="log-panel" id="processing-log"></div>
            </div>
        </main>
    </div>
    <script>
        const processor = {
            queue: [],
            watermark: null,
            currentFolderIndex: 0,
            currentImageIndex: 0,
            imageList: [],

            log(message, isError = false) {
                const logElement = document.getElementById('processing-log');
                const entry = document.createElement('div');
                entry.className = `log-entry${isError ? ' error' : ''}`;
                entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
                logElement.appendChild(entry);
                logElement.scrollTop = logElement.scrollHeight;
            }
        };

        // æ§ä»¶ç»‘å®š
        const initControls = () => {
            const bindControl = (sliderId, inputId, converter) => {
                const slider = document.getElementById(sliderId);
                const input = document.getElementById(inputId);
                
                slider.addEventListener('input', e => {
                    input.value = converter(e.target.value);
                    updatePreview();
                });
                
                input.addEventListener('input', e => {
                    slider.value = e.target.value / (converter(1) || 100);
                    updatePreview();
                });
            };

            bindControl('opacity', 'opacity-input', v => Math.round(v * 100));
            bindControl('scale', 'scale-input', v => Math.round(v * 100));
        };

        // æ–‡ä»¶å¤¹ç®¡ç†
        const updateFolderDisplay = () => {
            const container = document.getElementById('folder-queue');
            container.innerHTML = processor.queue.map((pair, index) => `
                <div class="folder-item">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                    </svg>
                    <div style="flex:1">
                        <div>${pair.name}</div>
                        <div style="font-size:0.9em;color:var(--text-light)">
                            è¾“å…¥ï¼š${pair.input.name} â†’ è¾“å‡ºï¼š${pair.output.name}
                        </div>
                    </div>
                    <button class="btn" onclick="removeFolderPair(${index})">Ã—</button>
                </div>
            `).join('<button class="btn btn-primary" onclick="addFolderPair()">ï¼‹ æ·»åŠ å¤„ç†ä»»åŠ¡</button>');
        };

        async function addFolderPair() {
            try {
                const [inputHandle, outputHandle] = await Promise.all([
                    window.showDirectoryPicker(),
                    window.showDirectoryPicker()
                ]);

                processor.queue.push({
                    input: inputHandle,
                    output: outputHandle,
                    name: `ä»»åŠ¡ç»„-${processor.queue.length + 1}`
                });
                
                updateFolderDisplay();
                processor.log(`âœ… å·²æ·»åŠ ä»»åŠ¡ç»„ï¼š${inputHandle.name}`);
                
                if (processor.queue.length === 1) {
                    await loadPreviewImages(0);
                }
            } catch (error) {
                processor.log(`âŒ æ·»åŠ å¤±è´¥ï¼š${error.message}`, true);
            }
        }

        // ä»¥ä¸‹ä¸ºå…¶ä»–æ ¸å¿ƒå‡½æ•°...
        // éœ€è¦ç»§ç»­è¡¥å……JavaScriptä»£ç 
    </script>
</body>
</html>

    <script>
        // ç¬¬å…­éƒ¨åˆ†ï¼šæ ¸å¿ƒåŠŸèƒ½å®ç°
        // å›¾ç‰‡åŠ è½½ä¸é¢„è§ˆç³»ç»Ÿ
        async function loadPreviewImages(folderIndex) {
            const folder = processor.queue[folderIndex];
            if (!folder) return;

            processor.imageList = [];
            processor.currentFolderIndex = folderIndex;
            
            // é€’å½’æ‰«æç›®å½•
            const scanDirectory = async (dirHandle, path = '') => {
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'directory') {
                        await scanDirectory(entry, `${path}${entry.name}/`);
                    } else if (/\.(png|jpe?g)$/i.test(entry.name)) {
                        processor.imageList.push({
                            handle: entry,
                            path: `${path}${entry.name}`
                        });
                    }
                }
            };

            await scanDirectory(folder.input);
            processor.currentImageIndex = 0;
            updatePreview();
            processor.log(`å·²åŠ è½½ ${folder.name} çš„ ${processor.imageList.length} å¼ å›¾ç‰‡`);
        }

        // é¢„è§ˆæ›´æ–°å‡½æ•°
        async function updatePreview() {
            const canvas = document.getElementById('preview-canvas');
            const ctx = canvas.getContext('2d');
            
            if (!processor.imageList.length) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }

            try {
                const entry = processor.imageList[processor.currentImageIndex];
                const file = await entry.handle.getFile();
                const img = await createImageBitmap(file);
                
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);

                if (processor.watermark) {
                    const scale = parseFloat(document.getElementById('scale').value);
                    const opacity = parseFloat(document.getElementById('opacity').value);
                    const wmWidth = processor.watermark.width * scale;
                    const wmHeight = processor.watermark.height * scale;
                    
                    // åŠ¨æ€ä½ç½®è®¡ç®—
                    const padding = 20;
                    const positionMap = {
                        'top-left': [padding, padding],
                        'top-right': [canvas.width - wmWidth - padding, padding],
                        'bottom-left': [padding, canvas.height - wmHeight - padding],
                        'bottom-right': [
                            canvas.width - wmWidth - padding,
                            canvas.height - wmHeight - padding
                        ],
                        'center': [
                            (canvas.width - wmWidth) / 2,
                            (canvas.height - wmHeight) / 2
                        ]
                    };
                    
                    const position = document.querySelector('#position-selector')?.value || 'bottom-right';
                    const [x, y] = positionMap[position];

                    ctx.globalAlpha = opacity;
                    ctx.drawImage(processor.watermark, x, y, wmWidth, wmHeight);
                    ctx.globalAlpha = 1.0;
                }

                document.getElementById('preview-counter').textContent = 
                    `${processor.currentFolderIndex+1}å·ä»»åŠ¡ç»„ ç¬¬${processor.currentImageIndex+1}/${processor.imageList.length}å¼ `;
            } catch (error) {
                processor.log(`é¢„è§ˆæ›´æ–°å¤±è´¥: ${error.message}`, true);
            }
        }

        // å¯¼èˆªæ§åˆ¶
        function changePreview(direction) {
            const newIndex = processor.currentImageIndex + direction;
            if (newIndex >= 0 && newIndex < processor.imageList.length) {
                processor.currentImageIndex = newIndex;
                updatePreview();
            }
        }

        // æ‰¹é‡å¤„ç†æ ¸å¿ƒ
        async function startProcessing() {
            if (!processor.watermark) {
                processor.log('âŒ è¯·å…ˆä¸Šä¼ æ°´å°å›¾ç‰‡', true);
                return;
            }

            for (let i = 0; i < processor.queue.length; i++) {
                const folder = processor.queue[i];
                processor.log(`ğŸš§ å¼€å§‹å¤„ç†ä»»åŠ¡ç»„: ${folder.name}`);
                
                try {
                    await processFolder(folder.input, folder.output);
                    processor.log(`âœ… å®Œæˆå¤„ç†: ${folder.name}`);
                } catch (error) {
                    processor.log(`âŒ å¤„ç†å¤±è´¥: ${folder.name} - ${error.message}`, true);
                }
            }
            processor.log('ğŸ‰ æ‰€æœ‰ä»»åŠ¡å¤„ç†å®Œæˆ');
        }

        // é€’å½’å¤„ç†æ–‡ä»¶å¤¹
        async function processFolder(inputHandle, outputHandle, path = '') {
            // åˆ›å»ºè¾“å‡ºç›®å½•
            const outputDir = path ? 
                await outputHandle.getDirectoryHandle(path, { create: true }) : 
                outputHandle;

            // éå†è¾“å…¥ç›®å½•
            for await (const entry of inputHandle.values()) {
                const entryPath = `${path}${entry.name}`;
                
                if (entry.kind === 'directory') {
                    await processFolder(entry, outputHandle, `${entryPath}/`);
                } else if (entry.kind === 'file') {
                    if (/\.(png|jpe?g)$/i.test(entry.name)) {
                        await processFile(entry, outputDir, entryPath);
                    }
                }
            }
        }

        // å¤„ç†å•ä¸ªæ–‡ä»¶
        async function processFile(fileHandle, outputDir, filePath) {
            try {
                const file = await fileHandle.getFile();
                const img = await createImageBitmap(file);
                
                // åˆ›å»ºç”»å¸ƒ
                const canvas = new OffscreenCanvas(img.width, img.height);
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                // åº”ç”¨æ°´å°
                const scale = parseFloat(document.getElementById('scale').value);
                const opacity = parseFloat(document.getElementById('opacity').value);
                const wmWidth = processor.watermark.width * scale;
                const wmHeight = processor.watermark.height * scale;
                const [x, y] = [canvas.width - wmWidth - 20, canvas.height - wmHeight - 20];
                
                ctx.globalAlpha = opacity;
                ctx.drawImage(processor.watermark, x, y, wmWidth, wmHeight);
                
                // è¾“å‡ºæ–‡ä»¶
                const outputFile = await outputDir.getFileHandle(fileHandle.name, { create: true });
                const writable = await outputFile.createWritable();
                const blob = await canvas.convertToBlob({ type: file.type });
                await writable.write(blob);
                await writable.close();
                
                processor.log(`âœ” å·²è¾“å‡º: ${filePath}`);
            } catch (error) {
                processor.log(`âŒ å¤„ç†å¤±è´¥: ${filePath} - ${error.message}`, true);
                throw error;
            }
        }

        // åˆå§‹åŒ–æ§ä»¶
        initControls();
    </script>
</body>
</html>